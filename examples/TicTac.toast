0 empty def
[ 
	" " pop 
	"X" pop 
	"O" pop 
] playerStrings def

"%s|%s|%s\n" pop rowString def
"-----\n" pop sepString def
3 boardSize def
[ 
		# rows
		[ 0 1 2 ] [ 3 4 5 ] [ 6 7 8 ]
		# Cols
		[ 0 3 6 ] [ 1 4 7 ] [ 2 5 8 ]

		# Diag
		[ 0 4 8 ] [ 2 4 6 ]
]
winSet def
"0" pop debugInput def
boardSize boardSize * cellCount def
cellCount 1 + cellCountAndTurn def

{
	0 index 2 get playerStrings swap get
	1 index 1 get playerStrings swap get
	2 index 0 get playerStrings swap get
	rowString printf	
	sepString printf

	0 index 5 get playerStrings swap get
	1 index 4 get playerStrings swap get
	2 index 3 get playerStrings swap get

	rowString printf
	sepString printf

	0 index 8 get playerStrings swap get
	1 index 7 get playerStrings swap get
	2 index 6 get playerStrings swap get

	rowString printf
	pop
} printBoard def

{
	"Player " print
	1+ printNum
	"'s turn\n" print
} printTurn def
{
	cellCountAndTurn copy
} copyState def

{
	dup
	1 get
	printTurn call
	dup
	0 get
	printBoard call
} printState def
# {
# 	# condFunc block

# 	1 index call
# 	# call
# 	{
# 		# dup call
# 		while
# 		"True!" pop printf
# 	}
# 	if
# } while def

[
	# Board
	[ 
	empty empty empty 
	empty empty empty 
	empty empty empty 
	# 1 1 1
	]
	
	# [ 
	# 	0 1 1 
	# 	2 3 5 
	# 	8 13 21 
	# ]

	# Turn Counter
	0
]

# printState call

# "3819" pop stringToInt printNum
{
	# ... func:FuncPtr items:int
	# func: A function run each loop return the number of those items it won't use, and a bool
	# items: The number of items to copy from the top of the stack before loop
	# ..... s[items -> 0] => .... s[numLeft -> 0] bool numLeft

	# Get conditions
	# whileInputs 1
	dup 
	{ 1 index }
	{ 
		dup 2 + copy
		pop
	} ifelse
	call       # ['items' values] func items ['numLeft' values] bool numLeft

	dup {
		pop
	}
	{

	dup        # ['items' values] func items ['numLeft' values] bool numLeft numLeft

	4+ -2 roll # ['items' values] ['numLeft' values] bool numLeft func items
	
	swap # ['items' values] ['numLeft' values] bool numLeft items func

	4 1 roll # ['items' values] ['numLeft' values] func bool numLeft items

	## TODO: This is Handling extra data. Think over if we want to do this here or at call
	swap dup # ['items' values] ['numLeft' values] func bool items numLeft numLeft
	2 index  # ['items' values] ['numLeft' values] func bool items numLeft numLeft items
	5+ 1 roll  # ['items'+1 values ...{numLeft}...] ['numLeft' values] func bool items numLeft

	2 copy  # ['items'+1 values ...{numLeft}...] ['numLeft' values] func bool items numLeft items numLeft
	4 + + # ['items'+1 values ...{numLeft}...] ['numLeft' values] func bool items numLeft ((items+numLeft)+4)
	swap # ['items'+1 values ...{numLeft}...] ['numLeft' values] func bool items ((items+numLeft)+4) numLeft
	1+ # ['items'+1 values ...{numLeft}...] ['numLeft' values] func bool items ((items+numLeft)+4) (numLeft+1)
	0 swap - # ['items'+1 values ...{numLeft}...] ['numLeft' values] func bool items ((items+numLeft)+4) -(numLeft+1) 
	roll # ['numLeft-items'values from items] ['numLeft' values] func bool  items ['numLeft' values from items] numLeft
	popN # ['numLeft-items'values from items] ['numLeft' values] func bool  items 
	swap # ['numLeft-items'values from items] ['numLeft' values] func items bool  
	}
	ifelse


	# ['numLeft' values] func items bool

	{
		{
			pop
			pop
		}
	}
	{
		doWhile
	}
	ifelse
	call
} doWhile def

{ + readByte } getChar def
{ dup getChar call } copyChar def
{ + 1 print } printChar def

# while printNum
# 0
# { 	
# 	#... n:int
# 	dup "Num: %d\n" pop printf
# 	# Increment
# 	1+
# 	#Check Size (and negate)
# 	dup 5 >
# 	1 swap -

# 	#Number of data items on stack
# 	1
# }
# 1
# doWhile call
{
0 
{ 	
	pop
	printState call
	
	# [ 1 2 3 4 5 6 7 8 9]
	# printBoard call
	"Pick an open spot [Enter a number 1-9]: " print
	#... n:int

	## Use the numbers 1-9 in order
	# debugInput dup dup readByte 
	# dup 57 < { 3 exit }{ 1+ } ifelse
	# writeByte

	## Use user input
	input pop	 

	## Use the number 6 every time
	# "6" pop	

	stringToInt 1 -

	dup dup
	-1 >
	swap 9 <
	# And
	
	*

	2 index 0 get 
	2 index get
	0 =
	*

	#negate
	1 swap -
	dup {
		"Invalid spot. Please try again.\n" print
	} if

	2
}
2
doWhile call
} getCellIndex def
{
getCellIndex call
# dup

# swap
# printState call
# swap
1 index
0 get
2 index 
1 get 1 +
3 1 roll
swap
set
dup
1 get
1 swap -
1 index 1 set
} run def

{
	0 get
	winSet
	0 # 0 # winFoundBool
	{
		# - board winSet index

		3 copy
		# - board winSet index board winSet index

		dup
		# - board winSet index board winSet index index

		3 1 roll
		# - board winSet index board index winSet index

		get
		# - board winSet index board index winIndecies

		# dup 0 get printNum
		# # - board winSet index board index winIndecies [printed WinIndex2]

		# dup 1 get printNum
		# # - board winSet index board index winIndecies [printed WinIndex1]

		# dup 2 get printNum
		# # - board winSet index board index winIndecies [printed WinIndex0]

		0 index 0 get 3 index swap get
		# - board winSet index board index winIndecies BoardValue0
		1 index 1 get 4 index swap get
		# - board winSet index board index winIndecies BoardValue0 BoardValue1
		2 index 2 get 5 index swap get
		# - board winSet index board index winIndecies BoardValue0 BoardValue1 BoardValue2

		6 3 roll
		# - board winSet index BoardValue0 BoardValue1 BoardValue2 board index winIndecies

		3 popN
		# - board winSet index BoardValue0 BoardValue1 BoardValue2

		# TODO: Instead of printNums

		2 index
		# - board winSet index BoardValue0 BoardValue1 BoardValue2 BoardValue0

		4 1 roll
		# - board winSet index BoardValue0 BoardValue0 BoardValue1 BoardValue2

		1 index
		# - board winSet index BoardValue0 BoardValue0 BoardValue1 BoardValue2 BoardValue1

		=
		# - board winSet index BoardValue0 BoardValue0 BoardValue1 (BoardValue2=BoardValue1)

		3 1 roll
		# - board winSet index BoardValue0 (BoardValue2=BoardValue1) BoardValue0 BoardValue1 

		=
		# - board winSet index BoardValue0 (BoardValue2=BoardValue1) (BoardValue0=BoardValue1)

		*
		# - board winSet index BoardValue0 ((BoardValue2=BoardValue1) && (BoardValue0=BoardValue1))

		1 index 0 !=
		# - board winSet index BoardValue0 ((BoardValue2=BoardValue1) && (BoardValue0=BoardValue1)) (BoardValue0 != 0)
		
		*
		# - board winSet index BoardValue0 ((BoardValue2=BoardValue1) && (BoardValue0=BoardValue1) && BoardValue0 != 0)
 		
		*
		# - board winSet index (((BoardValue2=BoardValue1) && (BoardValue0=BoardValue1) && BoardValue0 != 0)? BoardValue0: 0)

		dup { pop 1+ dup 8 < } { swap pop 0 } ifelse
		# - ((BoardValue2=BoardValue1) && (BoardValue0=BoardValue1) && BoardValue0 != 0)
		#     - board winSet BoardValue0 0
		#     - board winSet (index+1) (index+1<8) 

		3
		# - board winSet (index+1) (index+1 < 7) 3
	} 3
	doWhile call

	# remove the board and winIndecies
	3 1 roll 2 popN

	# If there's an 8 at the top of the stack, nobody won yet
	dup 8 =
	{
		pop 
		0
	}
	if
	# otherwise just return their number
} checkWin def

{
	dup
	run call
	# "printNum" print
	checkWin call 
	dup
	{
		pop pop 1
	}
	{
		"Player %d wins!\n" pop printf
		0 get
		printBoard call
		pop
		0
	}
	ifelse
	0
} 1 doWhile call

